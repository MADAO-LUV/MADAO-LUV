"""
编程实现:
有N个正整数，则对N个正整数进行不同方式的排列，每次排列后都会按照一下规则进行一次计算
聪明的小蓝发现，排列的方式不同，最后计算出的结果也相同
计算规则:
第一次:第一个数乘以第二个数乘以第三个数，结果记录为M(1)
第二次：第二个数乘以第三个数乘以第四个数，结果记录为M(2)
第三次:第三个数乘以第四个数乘以第五个数，结果记录为:M(3)
.....
第N-2次:第N-2个数乘以第N-1个数乘以第N个数，结果记录为M(N-2)
最后计算M(1)+M(2)+M(3)+.....M(N-2)的数值
找出一种排列方式使这个数值最大
例如:N=4,4个正整数分别为1，2，3，4，那么排列方式就会有24种
其中排列方式为1，3，4，2时，按照规则计算2次:1*3*4=12,3*4*2=24,乘积相加:12+24=36
这种排序方式是所有乘积相加的最大，为36
输入描述:
输入N个正整数(3<=N),正整数之间一个英文逗号隔开
输出描述:
找出所有乘积相*的数值最大的排列方式，并输出数值

"""
a = list(eval(input()))
n = len(a) #未插入前的长度
a.insert(0,0)
f = [0] * (n+1) #标记
b = [0] * (n+1) #存放结果(某一个排序)
maxp = 0 #最大值标记

def nums(i): #递归的层次
    global maxp
    if i == n+1:
        tmp = 0
        for j in range(n-1):
            tmp += b[j]*b[j+1]*b[j+2]
        if maxp < tmp:
            maxp = tmp
        return
    for x in range(1,n+1): #循环的编号
        if f[x] == 0:
            f[x] = 1
            b[i] = a[x]
            nums(i+1)
            f[x] = 0 #回溯


nums(1)
print(maxp)

