"""
题目描述
阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。
这条街上一共有 N家店铺，每家店中都有一些现金。
阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。
作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。
他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？

输入格式
输入的第一行是一个整数 T
，表示一共有 T组数据。

接下来的每组数据，第一行是一个整数 N
 ，表示一共有 N家店铺。

第二行是 N个被空格分开的正整数，表示每一家店铺中的现金数量。
每家店铺中的现金数量均不超过1000。

输出格式
对于每组数据，输出一行。
该行包含一个整数，表示阿福在不惊动警察的情况下可以得到的现金数量。
"""
N = int(1e5+10)
home = [0 for i in range(N)]
#要是想实现记忆化搜索的话，那么dfs的参数要尽可能的少，
# 不应该把没有影响到边界的数 放进来
#想要进行剪枝，就需要尽可能的把能剪枝的参数写上来
T = int(input())
f = [0 for i in range(N)]
for i in range(T):
    n = eval(input())
    a = [0] + list(map(int,input().split()))
    for i in range(1,n+1):
        home[i] = a[i]
    mem = [0 for x in range(N)]  # 每次都重新设置一下记忆化数组
    #算法优化
    newf,tmp1,tmp2 = 0,0,0
    for i in range(1,n+1):
        newf = max(tmp1,tmp2+home[i])
        tmp2 = tmp1
        tmp1 = newf #表示的是，赋予上一次的最大值，为了下一次的max
    print(newf)
#倒叙输出 递推 从底部一步一步往上推
#dfs --> 记忆化搜索 --> 倒叙递推 --> 正序递推 --> 空间优化


