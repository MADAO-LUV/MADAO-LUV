"""
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列
。
示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4

示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1

1.重述问题：在一个长度为n的数组中找最长递增的子序列，求长度
子序列 != 子数组 子数组中不可以跳过元素

2.找到最后一步：选择了某个数作为最长递增子序列的结尾

3.去掉最后一步,问题变成了什么:找到以3结尾前面选择的那个数结尾的最长递增子序列

4.考虑
改为记忆化搜索
"""
nums = eval(input())
n = len(nums)
res = -1e9
N = 3010
mem = [0 for i in range(N)]
#x为传输上的下标 枚举从开到到以下标为结尾
#最后统计原问题，需要在最后一步把+1 因为这里模拟的是去掉最后一步
def dfs(x):
#dfs函数里面的cnt要给1，因为以第x个数为结尾的最长递增子序列至少为1
    cnt = 1
    if mem[x]:
        return mem[x]
    for i in range(0,x):
        if nums[i] < nums[x]:
            cnt = max(cnt,dfs(i)+1)
    mem[x] = cnt
    return cnt

for i in range(0,n):
    res = max(res,dfs(i))
print(res)
#记得加上最后一步的那个长度 res最小为1

